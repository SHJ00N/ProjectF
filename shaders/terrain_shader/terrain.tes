#version 460 core
layout(quads, fractional_odd_spacing, ccw) in;

layout (std140, binding = 0) uniform CameraBlock
{
    mat4 projection;
    mat4 view;
    vec3 cameraPos;
    float cameraFov;
};

uniform sampler2D heightMap;
uniform float heightScale;

uniform int heightMapWidth;
uniform int heightMapHeight;
uniform float worldScale;

in vec2 TextureCoord[];

out vec2 TexCoords;
out mat3 TBN;
out vec3 Normal;

void main()
{
    float u = gl_TessCoord.x;
    float v = gl_TessCoord.y;

    vec4 p00 = gl_in[0].gl_Position;
    vec4 p01 = gl_in[1].gl_Position;
    vec4 p10 = gl_in[2].gl_Position;
    vec4 p11 = gl_in[3].gl_Position;

    vec4 p0 = (p01 - p00) * u + p00;
    vec4 p1 = (p11 - p10) * u + p10;
    vec4 p = (p1 - p0) * v + p0;

    vec2 worldUV = p.xz / (vec2(heightMapWidth, heightMapHeight) * worldScale);
    float Height = texture(heightMap, worldUV).r * heightScale;
    p.y += Height;

    vec2 texel = vec2(1.0 / heightMapWidth, 1.0 / heightMapHeight);
    float hL = texture(heightMap, worldUV - vec2(texel.x, 0)).r * heightScale;
    float hR = texture(heightMap, worldUV + vec2(texel.x, 0)).r * heightScale;
    float hD = texture(heightMap, worldUV - vec2(0, texel.y)).r * heightScale;
    float hU = texture(heightMap, worldUV + vec2(0, texel.y)).r * heightScale;

    vec3 dX = vec3(2.0 * worldScale, hR - hL, 0.0);
    vec3 dZ = vec3(0.0, hU - hD, 2.0 * worldScale);

    vec3 N = normalize(cross(dZ, dX));
    vec3 T = normalize(vec3(1.0, 0.0, 0.0));
    vec3 B = normalize(cross(N, T));
    T = normalize(cross(B, N));

    Normal = N;
    TBN = mat3(T, B, N);
    TexCoords = worldUV;

    gl_Position = projection * view * p;
}